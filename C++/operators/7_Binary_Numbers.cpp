#include <iostream>	

int main(void)
{
	using namespace std;

	// Binary Numbers - 이진수 0 1 0 1 

	/*
		(binary)				(decimal)
		0

		1


		10 = 2^1*1  +  2^0*0  =  2


		11 = 2^1*1  +  2^0*1  =  3
	
	---------------------------------------------------
		BINARY -> DECIMAL
		7654 3210 (2의 0제곱, 1제곱,2제곱....7제곱)   
		0101 1110 (1byte = 8bit) 

		= 2^7*0 + 2^6*1 + 2^5*0 + 2^4*1 + 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0
	
		= 128*0 + 64*1  + 32*0  + 16*1 +  8*1   + 4*1   + 2*1   + 1*0

		= 64    +   16  +   8   +  4   +   2
		= 94


	----------------------------------------------------
	DECIMAL -> BINARY  1

		148 

		148 / 2 =	74	r0 (r = ramainder = 나머지)

		74 / 2 =	37	r0 

		37 / 2 =	18	r1

		18 / 2 =	 9	r0

		9 / 2 =	 4	r1

		4 / 2 =	 2	r0

		2 / 2 =	 1	r0

		1 / 2 =	 0	r1 (여기서 거꾸로 올라감)

		--> 1001 0100 
			128+16+4=148
	----------------------------------------------------

	DECIMAL -> BINARY  2

		148

		2의 제곱수를 일단 나열  / 148 보다 작은수를 일단 찾아냄 (큰수부터) 

		1 2 3 4 5  6  7  8 .........(2진수 번째자리)
		1 2 4 8 16 32 64 128 256 512 1024 ........

		148 >= 128	->			YES  	128 =  2^7, 8번째 자리가 1
		
		148 - 128  =  20 >= 64	NO		64  =  2^6, 7번째 자리가 0
				   
				   =  20 >= 32  NO		32  =  2^5, 6번째 자리가 0

				   =  20 >= 16  YES		16  =  2^4, 5번째 자리가 1

		20  -  16  =   4 >=  8  NO		8   =  2^3, 4번째 자리가 0

				   =   4 >=  4  YES     4   =  2^2, 3번째 자리가 1

		4	-  4   =   0 (END)						2번째 자리가 0	

													1번째 자리가 0


		---->   1001 0100													
							
	----------------------------------------------------

	BINARY + BINARY  (단순 더하기 하듯이 / 1 + 1 = 10 으로 넘어감 


	    1 1
		
		0 1 1 0		(6 in decimal)
		
	 +	0 1 1 1		(7 in decimal) 
	 ___________
		1 1 0 1 = 13 in decimal         		


	----------------------------------------------------

	NEGATIVE NUMBER TO BINARY


		-5  

		0000 0101 ( Decimal +5)  <-- signed 변수에서의 맨 앞자리 0은 부호 표시 (앞이 1 -> 음수) 
		
		보수 complement ( 0 -> 1   &    1 -> 0  )
		
		1111 1010

		+1     < ----- 숫자 0을 표현할떄 (음의 0/ 양의 0) 2가지 숫자로 표현되는걸 막기위함    

		1111 1011  -> Decimal -5  


		0000 0000 (+0)

				  (보수처리)

		1111 1111 (-0)  ----> 여기에 binary 1 을 더해 양과 음의 0 을 같게 만듬
				  
				  ( + 1)

		0000 0000



	----------------------------------------------------
	NEGATIVE BINARY TO DECIMAL

		1001 1110	(8비트짜리 signed integer)  맨 앞 숫자 1 -> 음수 
		
						<- 보수 complement 
		0110 0001   
 		
						+ 1
		
		0110 0010       ->   98   -> -98 


						****  Signed  vs  unsigned  **** 
	  똑같은 2진수라도 signed 로써 10진수로 바꾸는거랑 
	  unsigned 로써 10진수로 바꾸는 거랑 값이 다름 
		
		(signed 라 가정)
		1001 1110  ->  2^7*1 + 2^4*1 + 2^3*1 + 2^2*1 + 2^1*1 = 128 + 16 + 8 + 4 + 2 



						**** 실수변환 ****
		floating point 의 표현 방식의 특징 때문에 실수 하나가 2가지로 분리가 되어 
		표현이 되는 측면이 있음





	return 0;

}